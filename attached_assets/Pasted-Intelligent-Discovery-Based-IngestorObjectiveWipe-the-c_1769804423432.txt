Intelligent Discovery-Based IngestorObjectiveWipe the current messy clauses database and implement a dynamic, style-based Ingestor. The system must automatically discover any .docx file in the templates folder and codify it into a hierarchical "Block" tree using document styling.Step 1: Schema Refactor (The Tree Structure)Modify shared/schema.ts to support recursive blocks:Contract Type: Change contractType in the clauses table from an Enum to a standard text field to allow discovery of new types (e.g., 'SUBMOD', 'NDA') without migrations.Block Type: Add a block_type column (text) with values: 'section', 'clause', 'paragraph', or 'table'.Hierarchy: Ensure parent_clause_id (integer) references clauses.id and hierarchy_level (integer) is strictly used for nesting depth.Run Migration: Execute npm run db:push to apply these changes.Step 2: Intelligent Ingestor Script (scripts/ingest_standard_contracts.ts)Create/Update the script with the following logic:File Discovery: Scan server/templates/ for all .docx files. Use the filename (minus extension) as the contract_type.Mammoth Integration: Use the mammoth library to convert Word documents to raw text while preserving styles.Styling-to-Hierarchy Map:Heading 1 $\rightarrow$ block_type: 'section', level: 1.Heading 2 $\rightarrow$ block_type: 'clause', level: 2.Normal / Body Text $\rightarrow$ block_type: 'paragraph', level: 3.Special Logic (Tables): If a block contains a variable ending in _TABLE (e.g., {{PAYMENT_SCHEDULE_TABLE}}), set block_type: 'table'.Clean Slate: The script must perform DELETE FROM clauses before processing to ensure no duplicate or messy legacy data remains.Variable Extraction: Extract all {{VARIABLE_NAME}} patterns into the variables_used array for each block.Step 3: Recursive Generator Engine (server/lib/contractGenerator.ts)Update the generation logic to handle the new tree:Tree Builder: Create a helper to fetch all blocks for a contract and arrange them into a nested JSON tree based on parent_clause_id.Logic Injection: When the generator encounters a block where block_type === 'table', it must call the corresponding helper in server/lib/tableGenerators.ts instead of printing literal text.Dynamic Numbering: Implement a numbering engine that calculates "1.", "1.1.", "1.1.1." on-the-fly based on the block's index within its parent. Ignore any hardcoded numbers in the source Word text.Verification TaskClear the server/templates/ folder and put only your original "Gold Standard" .docx files inside.Run npx tsx scripts/ingest_standard_contracts.ts.Generate a "ONE Agreement" PDF and verify that the sections are perfectly numbered and the pricing tables are dynamically injected.