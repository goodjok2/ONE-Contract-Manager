IMPLEMENT: Clean HTML/PDF Contract Generator
IMPLEMENT CLEAN HTML/PDF CONTRACT GENERATOR

Replace the current DOCX generation with a simpler HTML-to-PDF approach that matches Google Docs formatting.

STEP 1: INSTALL PUPPETEER
```bash
npm install puppeteer
npm install --save-dev @types/puppeteer
```

STEP 2: COMPLETELY REPLACE CONTRACT GENERATOR

Location: server/lib/contractGenerator.ts

Replace the entire file with this new implementation:
```typescript
import puppeteer from 'puppeteer';

interface ContractGenerationOptions {
  contractType: 'ONE' | 'MANUFACTURING' | 'ONSITE';
  projectData: Record<string, any>;
  format?: 'pdf' | 'html';
}

interface Clause {
  id: number;
  code: string;
  name: string;
  content: string;
  contractType: string;
  hierarchyLevel: string;
  category: string;
  conditions?: any;
  variablesUsed?: string[];
  order: number;
}

// ============================================================================
// MAIN GENERATION FUNCTION
// ============================================================================

export async function generateContract(options: ContractGenerationOptions): Promise<Buffer> {
  const { contractType, projectData, format = 'pdf' } = options;
  
  console.log(`\n=== Generating ${contractType} Contract (${format.toUpperCase()}) ===`);
  
  // 1. Fetch clauses from clause library API
  const clauses = await fetchClausesForContract(contractType, projectData);
  console.log(`✓ Fetched ${clauses.length} clauses`);
  
  // 2. Build variable map from project data
  const variableMap = buildVariableMap(projectData);
  console.log(`✓ Built variable map with ${Object.keys(variableMap).length} variables`);
  
  // 3. Replace variables in all clause content
  const processedClauses = clauses.map(clause => ({
    ...clause,
    content: replaceVariables(clause.content, variableMap)
  }));
  console.log(`✓ Processed ${processedClauses.length} clauses with variable replacement`);
  
  // 4. Generate HTML
  const html = generateHTMLFromClauses(processedClauses, contractType, projectData);
  
  if (format === 'html') {
    return Buffer.from(html, 'utf-8');
  }
  
  // 5. Convert HTML to PDF
  const pdfBuffer = await convertHTMLToPDF(html);
  console.log(`✓ Generated PDF: ${pdfBuffer.length} bytes\n`);
  
  return pdfBuffer;
}

// ============================================================================
// CLAUSE FETCHING (from PostgreSQL API)
// ============================================================================

async function fetchClausesForContract(
  contractType: string, 
  projectData: Record<string, any>
): Promise<Clause[]> {
  try {
    const url = `http://localhost:5000/api/clauses?contractType=${contractType}`;
    console.log(`Fetching clauses from: ${url}`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch clauses: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    const allClauses: Clause[] = data.clauses || [];
    
    console.log(`Received ${allClauses.length} total clauses from API`);
    
    // Filter clauses based on conditional logic
    const serviceModel = projectData.serviceModel || 'CRC';
    console.log(`Filtering clauses for service model: ${serviceModel}`);
    
    const filteredClauses = allClauses.filter(clause => {
      if (!clause.conditions) return true;
      
      let conditions = clause.conditions;
      if (typeof conditions === 'string') {
        try {
          conditions = JSON.parse(conditions);
        } catch (e) {
          console.warn(`Failed to parse conditions for clause ${clause.code}:`, conditions);
          return true;
        }
      }
      
      if (conditions.serviceModel && conditions.serviceModel !== serviceModel) {
        console.log(`Excluding clause ${clause.code} (requires ${conditions.serviceModel}, have ${serviceModel})`);
        return false;
      }
      
      return true;
    });
    
    console.log(`After filtering: ${filteredClauses.length} clauses will be included`);
    
    return filteredClauses.sort((a, b) => (a.order || 0) - (b.order || 0));
    
  } catch (error) {
    console.error('Error fetching clauses:', error);
    throw error;
  }
}

// ============================================================================
// VARIABLE REPLACEMENT
// ============================================================================

function replaceVariables(content: string, variableMap: Record<string, string>): string {
  if (!content) return '';
  
  let result = content;
  
  Object.entries(variableMap).forEach(([key, value]) => {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    result = result.replace(regex, value || '[NOT PROVIDED]');
  });
  
  return result;
}

// ============================================================================
// HTML GENERATION
// ============================================================================

function generateHTMLFromClauses(
  clauses: Clause[],
  contractType: string,
  projectData: Record<string, any>
): string {
  const title = getContractTitle(contractType);
  
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    @page {
      size: letter;
      margin: 1in;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      font-size: 11pt;
      line-height: 1.5;
      color: #000;
      background: #fff;
    }
    
    .contract-container {
      max-width: 8.5in;
      margin: 0 auto;
      padding: 40px;
    }
    
    /* Title Page */
    .title-page {
      text-align: center;
      padding-top: 3in;
      page-break-after: always;
    }
    
    .contract-title {
      font-size: 18pt;
      font-weight: bold;
      margin-bottom: 40pt;
      text-transform: uppercase;
    }
    
    .project-info {
      font-size: 14pt;
      margin-bottom: 12pt;
    }
    
    /* Section Headings */
    h1 {
      font-size: 14pt;
      font-weight: bold;
      margin-top: 24pt;
      margin-bottom: 12pt;
      text-transform: uppercase;
      page-break-after: avoid;
    }
    
    h2 {
      font-size: 12pt;
      font-weight: bold;
      margin-top: 18pt;
      margin-bottom: 10pt;
      page-break-after: avoid;
    }
    
    h3 {
      font-size: 11pt;
      font-weight: bold;
      margin-top: 12pt;
      margin-bottom: 8pt;
      page-break-after: avoid;
    }
    
    /* Paragraphs */
    p {
      margin-bottom: 12pt;
      text-align: left;
      line-height: 1.5;
    }
    
    .clause-code {
      font-weight: bold;
    }
    
    /* Lists */
    ol, ul {
      margin: 12pt 0;
      padding-left: 36pt;
    }
    
    li {
      margin-bottom: 6pt;
    }
    
    /* Print Styles */
    @media print {
      .contract-container {
        padding: 0;
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <div class="contract-container">
    ${renderTitlePage(title, projectData)}
    ${renderClausesHTML(clauses)}
  </div>
</body>
</html>
  `.trim();
}

function renderTitlePage(title: string, projectData: Record<string, any>): string {
  return `
    <div class="title-page">
      <div class="contract-title">${title}</div>
      <div class="project-info">
        <div><strong>Project ${escapeHtml(projectData.projectNumber || '')}</strong></div>
        <div>${escapeHtml(projectData.projectName || '')}</div>
      </div>
      ${projectData.agreementDate ? `
        <div style="margin-top: 40pt; font-size: 12pt;">
          ${formatDate(projectData.agreementDate)}
        </div>
      ` : ''}
    </div>
  `;
}

function renderClausesHTML(clauses: Clause[]): string {
  let html = '<div class="contract-body">';
  
  for (const clause of clauses) {
    if (clause.hierarchyLevel === 'SECTION') {
      html += `
        <h1>${clause.code ? `${escapeHtml(clause.code)}. ` : ''}${escapeHtml(clause.name || '')}</h1>
        ${clause.content ? `<p>${escapeHtml(clause.content)}</p>` : ''}
      `;
    } else if (clause.hierarchyLevel === 'SUBSECTION') {
      html += `
        <h2>${clause.code ? `${escapeHtml(clause.code)} ` : ''}${escapeHtml(clause.name || '')}</h2>
        ${clause.content ? `<p>${escapeHtml(clause.content)}</p>` : ''}
      `;
    } else if (clause.hierarchyLevel === 'PARAGRAPH') {
      if (clause.code && clause.code.trim()) {
        html += `
          <p>
            <span class="clause-code">${escapeHtml(clause.code)}.</span> 
            ${escapeHtml(clause.content || '')}
          </p>
        `;
      } else {
        html += `<p>${escapeHtml(clause.content || '')}</p>`;
      }
    }
  }
  
  html += '</div>';
  return html;
}

// ============================================================================
// PDF CONVERSION
// ============================================================================

async function convertHTMLToPDF(html: string): Promise<Buffer> {
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  try {
    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: 'networkidle0' });
    
    const pdfBuffer = await page.pdf({
      format: 'Letter',
      margin: {
        top: '1in',
        right: '1in',
        bottom: '1in',
        left: '1in'
      },
      printBackground: true,
      displayHeaderFooter: false
    });
    
    return pdfBuffer;
    
  } finally {
    await browser.close();
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function escapeHtml(text: string): string {
  if (!text) return '';
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

function getContractTitle(contractType: string): string {
  const titles: Record<string, string> = {
    'ONE': 'MASTER PURCHASE AGREEMENT',
    'MANUFACTURING': 'MANUFACTURING SUBCONTRACTOR AGREEMENT',
    'ONSITE': 'ON-SITE INSTALLATION SUBCONTRACTOR AGREEMENT'
  };
  return titles[contractType] || 'CONTRACT AGREEMENT';
}

function buildVariableMap(projectData: Record<string, any>): Record<string, string> {
  const map: Record<string, string> = {};
  
  // PROJECT INFO
  map['PROJECT_NUMBER'] = projectData.projectNumber || '';
  map['PROJECT_NAME'] = projectData.projectName || '';
  map['TOTAL_UNITS'] = projectData.totalUnits?.toString() || '1';
  map['AGREEMENT_EXECUTION_DATE'] = formatDate(projectData.agreementDate);
  
  // CLIENT INFO
  map['CLIENT_LEGAL_NAME'] = projectData.clientLegalName || '';
  map['CLIENT_STATE'] = projectData.clientState || '';
  map['CLIENT_ENTITY_TYPE'] = getEntityTypeText(projectData.clientEntityType);
  map['CLIENT_EMAIL'] = projectData.clientEmail || '';
  map['CLIENT_PHONE'] = projectData.clientPhone || '';
  map['CLIENT_SIGNER_NAME'] = projectData.clientSignerName || '';
  map['CLIENT_FULL_NAME'] = projectData.clientFullName || projectData.clientLegalName || '';
  map['CLIENT_TITLE'] = projectData.clientTitle || '';
  
  // LLC/SPV INFO
  const llcBaseName = projectData.childLlcName?.replace(' LLC', '').replace(', LLC', '') || 'Dvele Partners';
  map['DVELE_PARTNERS_XYZ'] = llcBaseName;
  map['DVELE_PARTNERS_XYZ_LEGAL_NAME'] = projectData.childLlcName || '';
  map['DVELE_PARTNERS_XYZ_STATE'] = projectData.childLlcState || 'Delaware';
  map['DVELE_PARTNERS_XYZ_ENTITY_TYPE'] = 'limited liability company';
  map['DP_X'] = projectData.childLlcName || '';
  map['DP_X_STATE'] = projectData.childLlcState || 'Delaware';
  
  // SITE/PROPERTY
  map['DELIVERY_ADDRESS'] = formatAddress(projectData);
  map['SITE_ADDRESS'] = projectData.siteAddress || '';
  map['SITE_CITY'] = projectData.siteCity || '';
  map['SITE_STATE'] = projectData.siteState || '';
  map['SITE_ZIP'] = projectData.siteZip || '';
  map['SITE_COUNTY'] = projectData.siteCounty || '';
  
  // UNITS
  const totalUnits = parseInt(projectData.totalUnits) || 1;
  for (let i = 1; i <= totalUnits; i++) {
    map[`UNIT_${i}_MODEL`] = projectData[`unit${i}Model`] || '';
    map[`UNIT_${i}_SQFT`] = projectData[`unit${i}Sqft`] || '';
    map[`UNIT_${i}_BEDROOMS`] = projectData[`unit${i}Bedrooms`]?.toString() || '';
    map[`UNIT_${i}_BATHROOMS`] = projectData[`unit${i}Bathrooms`]?.toString() || '';
    map[`UNIT_${i}_PRICE`] = formatCurrency(projectData[`unit${i}Price`]);
  }
  
  map['HOME_MODEL'] = projectData.unit1Model || '';
  map['HOME_MODEL_1'] = projectData.unit1Model || '';
  
  // FINANCIAL
  map['DESIGN_FEE'] = formatCurrency(projectData.designFee);
  map['DESIGN_REVISION_ROUNDS'] = projectData.designRevisionRounds?.toString() || '3';
  map['PRELIMINARY_OFFSITE_PRICE'] = formatCurrency(projectData.preliminaryOffsitePrice);
  map['DELIVERY_INSTALLATION_PRICE'] = formatCurrency(projectData.deliveryInstallationPrice);
  map['TOTAL_PRELIMINARY_CONTRACT_PRICE'] = formatCurrency(projectData.totalPreliminaryContractPrice);
  
  // MILESTONES
  map['MILESTONE_1_PERCENT'] = projectData.milestone1Percent?.toString() || '20';
  map['MILESTONE_2_PERCENT'] = projectData.milestone2Percent?.toString() || '20';
  map['MILESTONE_3_PERCENT'] = projectData.milestone3Percent?.toString() || '20';
  map['MILESTONE_4_PERCENT'] = projectData.milestone4Percent?.toString() || '20';
  map['MILESTONE_5_PERCENT'] = projectData.milestone5Percent?.toString() || '15';
  map['RETAINAGE_PERCENT'] = projectData.retainagePercent?.toString() || '5';
  map['RETAINAGE_DAYS'] = projectData.retainageDays?.toString() || '60';
  
  const totalPrice = parseFloat(projectData.totalPreliminaryContractPrice || '0');
  map['MILESTONE_1_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_1_PERCENT']) / 100));
  map['MILESTONE_2_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_2_PERCENT']) / 100));
  map['MILESTONE_3_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_3_PERCENT']) / 100));
  map['MILESTONE_4_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_4_PERCENT']) / 100));
  map['MILESTONE_5_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_5_PERCENT']) / 100));
  map['RETAINAGE_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['RETAINAGE_PERCENT']) / 100));
  
  // MANUFACTURING PAYMENTS
  map['MANUFACTURING_DESIGN_PAYMENT'] = formatCurrency(projectData.manufacturingDesignPayment);
  map['MANUFACTURING_PRODUCTION_START'] = formatCurrency(projectData.manufacturingProductionStart);
  map['MANUFACTURING_PRODUCTION_COMPLETE'] = formatCurrency(projectData.manufacturingProductionComplete);
  map['MANUFACTURING_DELIVERY_READY'] = formatCurrency(projectData.manufacturingDeliveryReady);
  
  // DATES
  map['AGREEMENT_DATE'] = formatDate(projectData.agreementDate);
  map['EFFECTIVE_DATE'] = formatDate(projectData.effectiveDate);
  map['ESTIMATED_COMPLETION_DATE'] = calculateEstimatedCompletion(projectData);
  map['DESIGN_PHASE_DAYS'] = projectData.designPhaseDays?.toString() || '90';
  map['MANUFACTURING_DURATION_DAYS'] = projectData.manufacturingDurationDays?.toString() || '120';
  map['ONSITE_DURATION_DAYS'] = projectData.onsiteDurationDays?.toString() || '90';
  
  // WARRANTY
  map['WARRANTY_FIT_FINISH_MONTHS'] = projectData.warrantyFitFinishMonths?.toString() || '24';
  map['WARRANTY_BUILDING_ENVELOPE_MONTHS'] = projectData.warrantyBuildingEnvelopeMonths?.toString() || '60';
  map['WARRANTY_STRUCTURAL_MONTHS'] = projectData.warrantyStructuralMonths?.toString() || '120';
  
  // LEGAL
  map['PROJECT_STATE'] = projectData.siteState || '';
  map['PROJECT_COUNTY'] = projectData.projectCounty || projectData.siteCounty || '';
  map['PROJECT_FEDERAL_DISTRICT'] = projectData.projectFederalDistrict || '';
  map['ARBITRATION_PROVIDER'] = projectData.arbitrationProvider || 'JAMS';
  
  // SERVICE MODEL
  map['ON_SITE_SERVICES_SELECTION'] = projectData.serviceModel === 'CRC' 
    ? 'CLIENT-RETAINED CONTRACTOR' 
    : 'COMPANY-MANAGED ON-SITE SERVICES';
  
  // CRC-SPECIFIC
  if (projectData.serviceModel === 'CRC') {
    map['ONSITE_PROVIDER_NAME'] = projectData.contractorName || '';
    map['CONTRACTOR_LICENSE'] = projectData.contractorLicense || '';
    map['CONTRACTOR_NAME'] = projectData.contractorName || '';
  }
  
  // CMOS-SPECIFIC
  if (projectData.serviceModel === 'CMOS') {
    map['SITE_PREP_PRICE'] = formatCurrency(projectData.sitePrepPrice);
    map['UTILITIES_PRICE'] = formatCurrency(projectData.utilitiesPrice);
    map['COMPLETION_PRICE'] = formatCurrency(projectData.completionPrice);
  }
  
  return map;
}

function formatCurrency(value: string | number | undefined): string {
  if (value === undefined || value === null || value === '') return '$0';
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '$0';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(num);
}

function formatDate(dateString: string | undefined): string {
  if (!dateString) return '';
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return '';
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

function formatAddress(projectData: Record<string, any>): string {
  const parts = [
    projectData.siteAddress,
    projectData.siteCity,
    projectData.siteState,
    projectData.siteZip
  ].filter(Boolean);
  return parts.join(', ');
}

function getEntityTypeText(entityType: string | undefined): string {
  const types: Record<string, string> = {
    'Individual': 'individual',
    'LLC': 'limited liability company',
    'Corporation': 'corporation',
    'Partnership': 'partnership',
    'Trust': 'trust'
  };
  return types[entityType || 'Individual'] || 'individual';
}

function calculateEstimatedCompletion(projectData: Record<string, any>): string {
  if (!projectData.effectiveDate) return '';
  
  const startDate = new Date(projectData.effectiveDate);
  const totalDays = (parseInt(projectData.designPhaseDays) || 0) +
                   (parseInt(projectData.manufacturingDurationDays) || 0) +
                   (parseInt(projectData.onsiteDurationDays) || 0);
  
  const completionDate = new Date(startDate);
  completionDate.setDate(completionDate.getDate() + totalDays);
  
  return formatDate(completionDate.toISOString());
}
```

STEP 3: UPDATE API ENDPOINT

In server/routes.ts, update to generate PDFs:
```typescript
app.post('/api/contracts/generate-package', async (req, res) => {
  try {
    const { wizardData } = req.body;
    
    if (!wizardData) {
      return res.status(400).json({ error: 'Missing wizard data' });
    }
    
    console.log('\n========================================');
    console.log('CONTRACT GENERATION REQUEST');
    console.log('Project:', wizardData.projectNumber, '-', wizardData.projectName);
    console.log('Service Model:', wizardData.serviceModel);
    console.log('========================================\n');
    
    const contracts = [];
    const projectId = `proj_${Date.now()}`;
    
    const outputDir = path.join(__dirname, '../generated_contracts');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    const contractTypes: Array<'ONE' | 'MANUFACTURING' | 'ONSITE'> = ['ONE', 'MANUFACTURING', 'ONSITE'];
    
    for (const contractType of contractTypes) {
      try {
        const buffer = await generateContract({
          contractType,
          projectData: wizardData,
          format: 'pdf'
        });
        
        const filename = `${contractType}_Agreement_${wizardData.projectNumber || 'DRAFT'}.pdf`;
        const filepath = path.join(outputDir, filename);
        
        fs.writeFileSync(filepath, buffer);
        console.log(`✓ Saved: ${filename} (${buffer.length} bytes)`);
        
        contracts.push({
          id: `contract_${Date.now()}_${contractType}`,
          type: contractType,
          filename,
          downloadUrl: `/api/contracts/download/${encodeURIComponent(filename)}`,
          size: buffer.length,
          generatedAt: new Date().toISOString()
        });
        
      } catch (error: any) {
        console.error(`✗ Failed to generate ${contractType}:`, error.message);
        throw error;
      }
    }
    
    console.log('\n========================================');
    console.log('✓ ALL CONTRACTS GENERATED SUCCESSFULLY');
    console.log('========================================\n');
    
    res.json({
      success: true,
      projectId,
      contracts
    });
    
  } catch (error: any) {
    console.error('Contract generation error:', error);
    res.status(500).json({ 
      error: 'Failed to generate contracts',
      message: error.message
    });
  }
});
```

STEP 4: TEST

1. Run the dev server
2. Load test project (2025-TEST-001)
3. Navigate to Step 9
4. Click "Generate Contract Package"
5. Wait for generation (Puppeteer takes a few seconds)
6. Download the three PDF files
7. Open in PDF viewer and verify:
   - Professional Google Docs-style formatting
   - All clauses present
   - CRC clauses included (since test project is CRC)
   - All variables replaced (no {{VARIABLE_NAME}} remaining)
   - Clean, readable layout

EXPECTED OUTPUT:
- ONE_Agreement_2025-TEST-001.pdf
- MANUFACTURING_Agreement_2025-TEST-001.pdf
- ONSITE_Agreement_2025-TEST-001.pdf

All files should be professional PDFs ready for legal review.

TROUBLESHOOTING:

If Puppeteer fails to launch:
- Check that Chrome/Chromium is available
- Replit should have it installed by default
- Check server logs for specific error

If PDFs look wrong:
- Check HTML output first (use format: 'html')
- Verify clauses are being fetched
- Check variable replacement in console logs

This implementation is much simpler and cleaner than DOCX generation!