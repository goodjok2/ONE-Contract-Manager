IMPLEMENT: Complete DOCX Contract Generation (Corrected Filenames)
IMPLEMENT COMPLETE DOCX CONTRACT GENERATION

The template files are ready and use {{VARIABLE_NAME}} format. Now implement the full generation system.

STEP 1: COPY TEMPLATE FILES

Copy the three uploaded template files to the server/templates/ directory:
```bash
mkdir -p server/templates
cp /mnt/user-data/uploads/7__26-00X_Project_Name_-_Dvele_ONE_Agreement.docx server/templates/Template_ONE_Agreement.docx
cp /mnt/user-data/uploads/8__Manufacturing_Subcontractor_Agreement_-_Company_to_Dvele_Manufacturing.docx server/templates/Template_Offsite.docx
cp /mnt/user-data/uploads/9__On-Site_Installation_Subcontractor_Agreement_-_Company_to_Service_Provider.docx server/templates/Template_On-Site.docx
```

STEP 2: INSTALL DEPENDENCIES
```bash
npm install docxtemplater pizzip
npm install --save-dev @types/pizzip
```

STEP 3: CREATE CONTRACT GENERATOR

Location: server/lib/contractGenerator.ts
```typescript
import Docxtemplater from 'docxtemplater';
import PizZip from 'pizzip';
import fs from 'fs';
import path from 'path';

interface ContractGenerationOptions {
  contractType: 'ONE' | 'MANUFACTURING' | 'ONSITE';
  projectData: Record<string, any>;
}

export async function generateContract(options: ContractGenerationOptions): Promise<Buffer> {
  const { contractType, projectData } = options;
  
  // 1. Load the template file
  const templatePath = getTemplatePath(contractType);
  
  if (!fs.existsSync(templatePath)) {
    throw new Error(`Template not found at: ${templatePath}`);
  }
  
  const content = fs.readFileSync(templatePath, 'binary');
  const zip = new PizZip(content);
  
  // 2. Create variable map from project data
  const variableMap = buildVariableMap(projectData, contractType);
  
  // 3. Generate document with docxtemplater
  const doc = new Docxtemplater(zip, {
    paragraphLoop: true,
    linebreaks: true,
    nullGetter: () => '', // Replace null/undefined with empty string
  });
  
  try {
    doc.render(variableMap);
  } catch (error: any) {
    console.error('Error rendering document:', error);
    throw new Error(`Failed to render ${contractType} contract: ${error.message}`);
  }
  
  const buffer = doc.getZip().generate({
    type: 'nodebuffer',
    compression: 'DEFLATE',
  });
  
  return buffer;
}

function getTemplatePath(contractType: string): string {
  const baseDir = path.join(__dirname, '../templates');
  
  const templates: Record<string, string> = {
    'ONE': path.join(baseDir, 'Template_ONE_Agreement.docx'),
    'MANUFACTURING': path.join(baseDir, 'Template_Offsite.docx'),
    'ONSITE': path.join(baseDir, 'Template_On-Site.docx'),
  };
  
  return templates[contractType];
}

function buildVariableMap(projectData: Record<string, any>, contractType: string): Record<string, string> {
  const map: Record<string, string> = {};
  
  // PROJECT INFO
  map['PROJECT_NUMBER'] = projectData.projectNumber || '';
  map['PROJECT_NAME'] = projectData.projectName || '';
  map['TOTAL_UNITS'] = projectData.totalUnits?.toString() || '1';
  map['AGREEMENT_EXECUTION_DATE'] = formatDate(projectData.agreementDate);
  
  // CLIENT INFO
  map['CLIENT_LEGAL_NAME'] = projectData.clientLegalName || '';
  map['CLIENT_STATE'] = projectData.clientState || '';
  map['CLIENT_ENTITY_TYPE'] = getEntityTypeText(projectData.clientEntityType);
  map['CLIENT_EMAIL'] = projectData.clientEmail || '';
  map['CLIENT_PHONE'] = projectData.clientPhone || '';
  map['CLIENT_SIGNER_NAME'] = projectData.clientSignerName || '';
  map['CLIENT_FULL_NAME'] = projectData.clientFullName || projectData.clientLegalName || '';
  map['CLIENT_TITLE'] = projectData.clientTitle || '';
  map['CLIENT_ADDRESS'] = projectData.clientAddress || '';
  map['CLIENT_CITY'] = projectData.clientCity || '';
  map['CLIENT_ZIP'] = projectData.clientZip || '';
  
  // LLC/SPV INFO
  const llcBaseName = projectData.childLlcName?.replace(' LLC', '') || 'Dvele Partners';
  map['DVELE_PARTNERS_XYZ'] = llcBaseName;
  map['DVELE_PARTNERS_XYZ_LEGAL_NAME'] = projectData.childLlcName || '';
  map['DVELE_PARTNERS_XYZ_STATE'] = projectData.childLlcState || 'Delaware';
  map['DVELE_PARTNERS_XYZ_ENTITY_TYPE'] = 'limited liability company';
  map['DP_X'] = projectData.childLlcName || '';
  map['DP_X_STATE'] = projectData.childLlcState || 'Delaware';
  
  // SITE/PROPERTY INFO
  map['DELIVERY_ADDRESS'] = formatAddress(projectData);
  map['SITE_ADDRESS'] = projectData.siteAddress || '';
  map['SITE_CITY'] = projectData.siteCity || '';
  map['SITE_STATE'] = projectData.siteState || '';
  map['SITE_ZIP'] = projectData.siteZip || '';
  map['SITE_COUNTY'] = projectData.siteCounty || '';
  
  // UNIT SPECIFICATIONS
  const totalUnits = parseInt(projectData.totalUnits) || 1;
  for (let i = 1; i <= totalUnits; i++) {
    map[`UNIT_${i}_MODEL`] = projectData[`unit${i}Model`] || '';
    map[`UNIT_${i}_SQFT`] = projectData[`unit${i}Sqft`] || '';
    map[`UNIT_${i}_BEDROOMS`] = projectData[`unit${i}Bedrooms`]?.toString() || '';
    map[`UNIT_${i}_BATHROOMS`] = projectData[`unit${i}Bathrooms`]?.toString() || '';
    map[`UNIT_${i}_PRICE`] = formatCurrency(projectData[`unit${i}Price`]);
  }
  
  // HOME MODEL (for single unit - often used as UNIT_1_MODEL alias)
  map['HOME_MODEL'] = projectData.unit1Model || '';
  map['HOME_MODEL_1'] = projectData.unit1Model || '';
  
  // FINANCIAL TERMS
  map['DESIGN_FEE'] = formatCurrency(projectData.designFee);
  map['DESIGN_REVISION_ROUNDS'] = projectData.designRevisionRounds?.toString() || '3';
  map['PRELIMINARY_OFFSITE_PRICE'] = formatCurrency(projectData.preliminaryOffsitePrice);
  map['DELIVERY_INSTALLATION_PRICE'] = formatCurrency(projectData.deliveryInstallationPrice);
  map['TOTAL_PRELIMINARY_CONTRACT_PRICE'] = formatCurrency(projectData.totalPreliminaryContractPrice);
  
  // PAYMENT MILESTONES
  map['MILESTONE_1_PERCENT'] = projectData.milestone1Percent?.toString() || '20';
  map['MILESTONE_2_PERCENT'] = projectData.milestone2Percent?.toString() || '20';
  map['MILESTONE_3_PERCENT'] = projectData.milestone3Percent?.toString() || '20';
  map['MILESTONE_4_PERCENT'] = projectData.milestone4Percent?.toString() || '20';
  map['MILESTONE_5_PERCENT'] = projectData.milestone5Percent?.toString() || '15';
  map['RETAINAGE_PERCENT'] = projectData.retainagePercent?.toString() || '5';
  map['RETAINAGE_DAYS'] = projectData.retainageDays?.toString() || '60';
  
  // Calculate milestone dollar amounts
  const totalPrice = parseFloat(projectData.totalPreliminaryContractPrice || '0');
  map['MILESTONE_1_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_1_PERCENT']) / 100));
  map['MILESTONE_2_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_2_PERCENT']) / 100));
  map['MILESTONE_3_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_3_PERCENT']) / 100));
  map['MILESTONE_4_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_4_PERCENT']) / 100));
  map['MILESTONE_5_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_5_PERCENT']) / 100));
  map['RETAINAGE_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['RETAINAGE_PERCENT']) / 100));
  
  // MANUFACTURING PAYMENTS
  map['MANUFACTURING_DESIGN_PAYMENT'] = formatCurrency(projectData.manufacturingDesignPayment);
  map['MANUFACTURING_PRODUCTION_START'] = formatCurrency(projectData.manufacturingProductionStart);
  map['MANUFACTURING_PRODUCTION_COMPLETE'] = formatCurrency(projectData.manufacturingProductionComplete);
  map['MANUFACTURING_DELIVERY_READY'] = formatCurrency(projectData.manufacturingDeliveryReady);
  
  // DATES & TIMELINE
  map['AGREEMENT_DATE'] = formatDate(projectData.agreementDate);
  map['EFFECTIVE_DATE'] = formatDate(projectData.effectiveDate);
  map['ESTIMATED_COMPLETION_DATE'] = calculateEstimatedCompletion(projectData);
  map['DESIGN_PHASE_DAYS'] = projectData.designPhaseDays?.toString() || '90';
  map['MANUFACTURING_DURATION_DAYS'] = projectData.manufacturingDurationDays?.toString() || '120';
  map['ONSITE_DURATION_DAYS'] = projectData.onsiteDurationDays?.toString() || '90';
  
  // WARRANTY
  map['WARRANTY_FIT_FINISH_MONTHS'] = projectData.warrantyFitFinishMonths?.toString() || '24';
  map['WARRANTY_BUILDING_ENVELOPE_MONTHS'] = projectData.warrantyBuildingEnvelopeMonths?.toString() || '60';
  map['WARRANTY_STRUCTURAL_MONTHS'] = projectData.warrantyStructuralMonths?.toString() || '120';
  
  // LEGAL JURISDICTION
  map['PROJECT_STATE'] = projectData.siteState || '';
  map['PROJECT_COUNTY'] = projectData.projectCounty || projectData.siteCounty || '';
  map['PROJECT_FEDERAL_DISTRICT'] = projectData.projectFederalDistrict || '';
  map['ARBITRATION_PROVIDER'] = projectData.arbitrationProvider || 'JAMS';
  
  // SERVICE MODEL
  map['ON_SITE_SERVICES_SELECTION'] = projectData.serviceModel === 'CRC' 
    ? 'CLIENT-RETAINED CONTRACTOR' 
    : 'COMPANY-MANAGED ON-SITE SERVICES';
  
  // CRC-SPECIFIC
  if (projectData.serviceModel === 'CRC') {
    map['ONSITE_PROVIDER_NAME'] = projectData.contractorName || '';
    map['CONTRACTOR_LICENSE'] = projectData.contractorLicense || '';
    map['CONTRACTOR_NAME'] = projectData.contractorName || '';
  }
  
  // CMOS-SPECIFIC
  if (projectData.serviceModel === 'CMOS') {
    map['SITE_PREP_PRICE'] = formatCurrency(projectData.sitePrepPrice);
    map['UTILITIES_PRICE'] = formatCurrency(projectData.utilitiesPrice);
    map['COMPLETION_PRICE'] = formatCurrency(projectData.completionPrice);
  }
  
  return map;
}

function formatCurrency(value: string | number | undefined): string {
  if (value === undefined || value === null || value === '') return '$0';
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '$0';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(num);
}

function formatDate(dateString: string | undefined): string {
  if (!dateString) return '';
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return '';
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

function formatAddress(projectData: Record<string, any>): string {
  const parts = [
    projectData.siteAddress,
    projectData.siteCity,
    projectData.siteState,
    projectData.siteZip
  ].filter(Boolean);
  return parts.join(', ');
}

function getEntityTypeText(entityType: string | undefined): string {
  const types: Record<string, string> = {
    'Individual': 'individual',
    'LLC': 'limited liability company',
    'Corporation': 'corporation',
    'Partnership': 'partnership',
    'Trust': 'trust'
  };
  return types[entityType || 'Individual'] || 'individual';
}

function calculateEstimatedCompletion(projectData: Record<string, any>): string {
  if (!projectData.effectiveDate) return '';
  
  const startDate = new Date(projectData.effectiveDate);
  const totalDays = (parseInt(projectData.designPhaseDays) || 0) +
                   (parseInt(projectData.manufacturingDurationDays) || 0) +
                   (parseInt(projectData.onsiteDurationDays) || 0);
  
  const completionDate = new Date(startDate);
  completionDate.setDate(completionDate.getDate() + totalDays);
  
  return formatDate(completionDate.toISOString());
}
```

STEP 4: UPDATE API ENDPOINT

In server/routes.ts, update the contract generation endpoint:
```typescript
import { generateContract } from './lib/contractGenerator';
import fs from 'fs';
import path from 'path';

app.post('/api/contracts/generate-package', async (req, res) => {
  try {
    const { wizardData } = req.body;
    
    if (!wizardData) {
      return res.status(400).json({ error: 'Missing wizard data' });
    }
    
    console.log('Generating contracts for project:', wizardData.projectNumber);
    
    const contracts = [];
    const projectId = `proj_${Date.now()}`;
    
    // Ensure output directory exists
    const outputDir = path.join(__dirname, '../generated_contracts');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Generate each contract type
    const contractTypes: Array<'ONE' | 'MANUFACTURING' | 'ONSITE'> = ['ONE', 'MANUFACTURING', 'ONSITE'];
    
    for (const contractType of contractTypes) {
      console.log(`Generating ${contractType} contract...`);
      
      const buffer = await generateContract({
        contractType,
        projectData: wizardData
      });
      
      // Create filename
      const filename = `${contractType}_Agreement_${wizardData.projectNumber || 'DRAFT'}.docx`;
      const filepath = path.join(outputDir, filename);
      
      // Save to disk
      fs.writeFileSync(filepath, buffer);
      console.log(`✓ Saved ${filename} (${buffer.length} bytes)`);
      
      contracts.push({
        id: `contract_${Date.now()}_${contractType}`,
        type: contractType,
        filename,
        downloadUrl: `/api/contracts/download/${encodeURIComponent(filename)}`,
        size: buffer.length,
        generatedAt: new Date().toISOString()
      });
    }
    
    console.log('✓ All contracts generated successfully');
    
    res.json({
      success: true,
      projectId,
      contracts,
      zipUrl: `/api/contracts/download-zip/${projectId}`
    });
    
  } catch (error: any) {
    console.error('Contract generation error:', error);
    res.status(500).json({ 
      error: 'Failed to generate contracts',
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Download individual contract
app.get('/api/contracts/download/:filename', (req, res) => {
  try {
    const filename = decodeURIComponent(req.params.filename);
    const filepath = path.join(__dirname, '../generated_contracts', filename);
    
    if (!fs.existsSync(filepath)) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
        res.status(500).json({ error: 'Download failed' });
      }
    });
  } catch (error) {
    console.error('Download error:', error);
    res.status(500).json({ error: 'Download failed' });
  }
});
```

STEP 5: CREATE GENERATED_CONTRACTS DIRECTORY
```bash
mkdir -p generated_contracts
```

STEP 6: VERIFY TEMPLATE FILES ARE IN PLACE

After copying, verify the templates exist:
```bash
ls -lh server/templates/
```

Should show:
- Template_ONE_Agreement.docx
- Template_Offsite.docx
- Template_On-Site.docx

STEP 7: TEST

1. Complete wizard with test project (2025-TEST-001)
2. Navigate to Step 9
3. Check confirmation box
4. Click "Generate Contract Package"
5. Wait for generation to complete
6. Download each of the three .docx files
7. Open in Microsoft Word or Google Docs
8. Verify:
   - Professional formatting is preserved
   - All variables are replaced with actual values
   - No {{VARIABLE_NAME}} placeholders remain
   - Document structure looks correct
   - Headers, footers, and styling intact

TROUBLESHOOTING:

If you see "Template not found" error:
- Check that templates are in server/templates/ directory
- Verify filenames match exactly: Template_ONE_Agreement.docx, Template_Offsite.docx, Template_On-Site.docx

If variables aren't replaced:
- Check server logs to see which variables are being mapped
- Open generated .docx and search for {{
- Compare variable names in template with variable map

If generation fails:
- Check server console for error messages
- Verify docxtemplater and pizzip are installed
- Check file permissions on templates directory