IMPLEMENT: Dynamic Contract Generator from Clause Library
IMPLEMENT DYNAMIC CONTRACT GENERATOR USING CLAUSE LIBRARY API

Build a contract generator that queries the PostgreSQL clause library, filters clauses based on conditions (CRC/CMOS), and dynamically assembles formatted DOCX files.

STEP 1: INSTALL REQUIRED DEPENDENCIES
```bash
npm install docx node-fetch
npm install --save-dev @types/node-fetch
```

STEP 2: CREATE CONTRACT GENERATOR

Location: server/lib/contractGenerator.ts

Create a new file with this complete implementation:
```typescript
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, PageBreak, TabStopType, TabStopPosition } from 'docx';

interface ContractGenerationOptions {
  contractType: 'ONE' | 'MANUFACTURING' | 'ONSITE';
  projectData: Record<string, any>;
}

interface Clause {
  id: number;
  code: string;
  name: string;
  content: string;
  contractType: string;
  hierarchyLevel: string;
  category: string;
  conditions?: any;
  variablesUsed?: string[];
  order: number;
}

export async function generateContract(options: ContractGenerationOptions): Promise<Buffer> {
  const { contractType, projectData } = options;
  
  console.log(`\n=== Generating ${contractType} Contract ===`);
  
  // 1. Fetch clauses from clause library API
  const clauses = await fetchClausesForContract(contractType, projectData);
  console.log(`✓ Fetched ${clauses.length} clauses`);
  
  // 2. Build variable map from project data
  const variableMap = buildVariableMap(projectData);
  console.log(`✓ Built variable map with ${Object.keys(variableMap).length} variables`);
  
  // 3. Replace variables in all clause content
  const processedClauses = clauses.map(clause => ({
    ...clause,
    content: replaceVariables(clause.content, variableMap)
  }));
  console.log(`✓ Processed ${processedClauses.length} clauses with variable replacement`);
  
  // 4. Generate DOCX document from clauses
  const buffer = await generateDocxFromClauses(processedClauses, contractType, projectData, variableMap);
  console.log(`✓ Generated DOCX: ${buffer.length} bytes\n`);
  
  return buffer;
}

async function fetchClausesForContract(
  contractType: string, 
  projectData: Record<string, any>
): Promise<Clause[]> {
  try {
    // Query the clause library API
    const url = `http://localhost:5000/api/clauses?contractType=${contractType}`;
    console.log(`Fetching clauses from: ${url}`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch clauses: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    const allClauses: Clause[] = data.clauses || [];
    
    console.log(`Received ${allClauses.length} total clauses from API`);
    
    // Filter clauses based on conditional logic
    const serviceModel = projectData.serviceModel || 'CRC';
    console.log(`Filtering clauses for service model: ${serviceModel}`);
    
    const filteredClauses = allClauses.filter(clause => {
      // If no conditions, include the clause
      if (!clause.conditions) {
        return true;
      }
      
      // Parse conditions if string
      let conditions = clause.conditions;
      if (typeof conditions === 'string') {
        try {
          conditions = JSON.parse(conditions);
        } catch (e) {
          console.warn(`Failed to parse conditions for clause ${clause.code}:`, conditions);
          return true; // Include if can't parse
        }
      }
      
      // Check service model condition
      if (conditions.serviceModel) {
        if (conditions.serviceModel !== serviceModel) {
          console.log(`Excluding clause ${clause.code} (requires ${conditions.serviceModel}, have ${serviceModel})`);
          return false;
        }
      }
      
      // Add more condition checks as needed
      // e.g., conditions.unitCount, conditions.state, etc.
      
      return true;
    });
    
    console.log(`After filtering: ${filteredClauses.length} clauses will be included`);
    
    // Sort by order
    return filteredClauses.sort((a, b) => (a.order || 0) - (b.order || 0));
    
  } catch (error) {
    console.error('Error fetching clauses:', error);
    throw error;
  }
}

function replaceVariables(content: string, variableMap: Record<string, string>): string {
  if (!content) return '';
  
  let result = content;
  
  // Replace all {{VARIABLE_NAME}} placeholders
  Object.entries(variableMap).forEach(([key, value]) => {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    result = result.replace(regex, value || '[NOT PROVIDED]');
  });
  
  return result;
}

async function generateDocxFromClauses(
  clauses: Clause[],
  contractType: string,
  projectData: Record<string, any>,
  variableMap: Record<string, string>
): Promise<Buffer> {
  const children: any[] = [];
  
  // Add title page
  children.push(
    new Paragraph({
      text: getContractTitle(contractType),
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { before: 400, after: 400 }
    }),
    new Paragraph({
      text: variableMap.PROJECT_NUMBER || '',
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 }
    }),
    new Paragraph({
      text: variableMap.PROJECT_NAME || '',
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }),
    new PageBreak()
  );
  
  // Add each clause
  for (const clause of clauses) {
    const paragraphs = convertClauseToParagraphs(clause);
    children.push(...paragraphs);
  }
  
  // Create document with proper styling
  const doc = new Document({
    sections: [{
      properties: {
        page: {
          margin: {
            top: 1440,    // 1 inch
            right: 1440,
            bottom: 1440,
            left: 1440
          }
        }
      },
      children: children
    }]
  });
  
  // Generate buffer
  const buffer = await Packer.toBuffer(doc);
  return buffer;
}

function convertClauseToParagraphs(clause: Clause): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  // Determine heading level based on hierarchy
  if (clause.hierarchyLevel === 'SECTION') {
    // Main section heading (e.g., "1. SCOPE OF SERVICES")
    paragraphs.push(
      new Paragraph({
        text: clause.name || '',
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 400, after: 200 },
        numbering: clause.code ? {
          reference: 'section-numbering',
          level: 0
        } : undefined
      })
    );
    
    // Add section content if exists
    if (clause.content && clause.content.trim()) {
      const contentParagraphs = splitContentIntoParagraphs(clause.content);
      paragraphs.push(...contentParagraphs);
    }
    
  } else if (clause.hierarchyLevel === 'SUBSECTION') {
    // Subsection heading (e.g., "1.1 Design Services")
    paragraphs.push(
      new Paragraph({
        text: `${clause.code ? clause.code + ' ' : ''}${clause.name || ''}`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 300, after: 150 }
      })
    );
    
    // Add subsection content
    if (clause.content && clause.content.trim()) {
      const contentParagraphs = splitContentIntoParagraphs(clause.content);
      paragraphs.push(...contentParagraphs);
    }
    
  } else if (clause.hierarchyLevel === 'PARAGRAPH') {
    // Paragraph-level clause (the actual content)
    const content = clause.content || '';
    
    if (clause.code && clause.code.trim()) {
      // Has a code prefix (e.g., "1.1.1")
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${clause.code}. `,
              bold: true
            }),
            new TextRun({
              text: content
            })
          ],
          spacing: { before: 120, after: 120 }
        })
      );
    } else {
      // No code, just content
      const contentParagraphs = splitContentIntoParagraphs(content);
      paragraphs.push(...contentParagraphs);
    }
  }
  
  return paragraphs;
}

function splitContentIntoParagraphs(content: string): Paragraph[] {
  if (!content || !content.trim()) {
    return [];
  }
  
  // Split by double newlines (paragraph breaks) or single newlines
  const lines = content.split('\n').filter(line => line.trim());
  
  return lines.map(line => 
    new Paragraph({
      text: line.trim(),
      spacing: { before: 120, after: 120 }
    })
  );
}

function getContractTitle(contractType: string): string {
  const titles: Record<string, string> = {
    'ONE': 'MASTER PURCHASE AGREEMENT',
    'MANUFACTURING': 'MANUFACTURING SUBCONTRACTOR AGREEMENT',
    'ONSITE': 'ON-SITE INSTALLATION SUBCONTRACTOR AGREEMENT'
  };
  
  return titles[contractType] || 'CONTRACT AGREEMENT';
}

function buildVariableMap(projectData: Record<string, any>): Record<string, string> {
  const map: Record<string, string> = {};
  
  // PROJECT INFO
  map['PROJECT_NUMBER'] = projectData.projectNumber || '';
  map['PROJECT_NAME'] = projectData.projectName || '';
  map['TOTAL_UNITS'] = projectData.totalUnits?.toString() || '1';
  map['AGREEMENT_EXECUTION_DATE'] = formatDate(projectData.agreementDate);
  
  // CLIENT INFO
  map['CLIENT_LEGAL_NAME'] = projectData.clientLegalName || '';
  map['CLIENT_STATE'] = projectData.clientState || '';
  map['CLIENT_ENTITY_TYPE'] = getEntityTypeText(projectData.clientEntityType);
  map['CLIENT_EMAIL'] = projectData.clientEmail || '';
  map['CLIENT_PHONE'] = projectData.clientPhone || '';
  map['CLIENT_SIGNER_NAME'] = projectData.clientSignerName || '';
  map['CLIENT_FULL_NAME'] = projectData.clientFullName || projectData.clientLegalName || '';
  map['CLIENT_TITLE'] = projectData.clientTitle || '';
  
  // LLC/SPV INFO
  const llcBaseName = projectData.childLlcName?.replace(' LLC', '').replace(', LLC', '') || 'Dvele Partners';
  map['DVELE_PARTNERS_XYZ'] = llcBaseName;
  map['DVELE_PARTNERS_XYZ_LEGAL_NAME'] = projectData.childLlcName || '';
  map['DVELE_PARTNERS_XYZ_STATE'] = projectData.childLlcState || 'Delaware';
  map['DVELE_PARTNERS_XYZ_ENTITY_TYPE'] = 'limited liability company';
  map['DP_X'] = projectData.childLlcName || '';
  map['DP_X_STATE'] = projectData.childLlcState || 'Delaware';
  
  // SITE/PROPERTY INFO
  map['DELIVERY_ADDRESS'] = formatAddress(projectData);
  map['SITE_ADDRESS'] = projectData.siteAddress || '';
  map['SITE_CITY'] = projectData.siteCity || '';
  map['SITE_STATE'] = projectData.siteState || '';
  map['SITE_ZIP'] = projectData.siteZip || '';
  map['SITE_COUNTY'] = projectData.siteCounty || '';
  
  // UNIT SPECIFICATIONS
  const totalUnits = parseInt(projectData.totalUnits) || 1;
  for (let i = 1; i <= totalUnits; i++) {
    map[`UNIT_${i}_MODEL`] = projectData[`unit${i}Model`] || '';
    map[`UNIT_${i}_SQFT`] = projectData[`unit${i}Sqft`] || '';
    map[`UNIT_${i}_BEDROOMS`] = projectData[`unit${i}Bedrooms`]?.toString() || '';
    map[`UNIT_${i}_BATHROOMS`] = projectData[`unit${i}Bathrooms`]?.toString() || '';
    map[`UNIT_${i}_PRICE`] = formatCurrency(projectData[`unit${i}Price`]);
  }
  
  map['HOME_MODEL'] = projectData.unit1Model || '';
  map['HOME_MODEL_1'] = projectData.unit1Model || '';
  
  // FINANCIAL TERMS
  map['DESIGN_FEE'] = formatCurrency(projectData.designFee);
  map['DESIGN_REVISION_ROUNDS'] = projectData.designRevisionRounds?.toString() || '3';
  map['PRELIMINARY_OFFSITE_PRICE'] = formatCurrency(projectData.preliminaryOffsitePrice);
  map['DELIVERY_INSTALLATION_PRICE'] = formatCurrency(projectData.deliveryInstallationPrice);
  map['TOTAL_PRELIMINARY_CONTRACT_PRICE'] = formatCurrency(projectData.totalPreliminaryContractPrice);
  
  // PAYMENT MILESTONES
  map['MILESTONE_1_PERCENT'] = projectData.milestone1Percent?.toString() || '20';
  map['MILESTONE_2_PERCENT'] = projectData.milestone2Percent?.toString() || '20';
  map['MILESTONE_3_PERCENT'] = projectData.milestone3Percent?.toString() || '20';
  map['MILESTONE_4_PERCENT'] = projectData.milestone4Percent?.toString() || '20';
  map['MILESTONE_5_PERCENT'] = projectData.milestone5Percent?.toString() || '15';
  map['RETAINAGE_PERCENT'] = projectData.retainagePercent?.toString() || '5';
  map['RETAINAGE_DAYS'] = projectData.retainageDays?.toString() || '60';
  
  // Calculate milestone dollar amounts
  const totalPrice = parseFloat(projectData.totalPreliminaryContractPrice || '0');
  map['MILESTONE_1_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_1_PERCENT']) / 100));
  map['MILESTONE_2_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_2_PERCENT']) / 100));
  map['MILESTONE_3_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_3_PERCENT']) / 100));
  map['MILESTONE_4_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_4_PERCENT']) / 100));
  map['MILESTONE_5_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['MILESTONE_5_PERCENT']) / 100));
  map['RETAINAGE_AMOUNT'] = formatCurrency(totalPrice * (parseFloat(map['RETAINAGE_PERCENT']) / 100));
  
  // MANUFACTURING PAYMENTS
  map['MANUFACTURING_DESIGN_PAYMENT'] = formatCurrency(projectData.manufacturingDesignPayment);
  map['MANUFACTURING_PRODUCTION_START'] = formatCurrency(projectData.manufacturingProductionStart);
  map['MANUFACTURING_PRODUCTION_COMPLETE'] = formatCurrency(projectData.manufacturingProductionComplete);
  map['MANUFACTURING_DELIVERY_READY'] = formatCurrency(projectData.manufacturingDeliveryReady);
  
  // DATES & TIMELINE
  map['AGREEMENT_DATE'] = formatDate(projectData.agreementDate);
  map['EFFECTIVE_DATE'] = formatDate(projectData.effectiveDate);
  map['ESTIMATED_COMPLETION_DATE'] = calculateEstimatedCompletion(projectData);
  map['DESIGN_PHASE_DAYS'] = projectData.designPhaseDays?.toString() || '90';
  map['MANUFACTURING_DURATION_DAYS'] = projectData.manufacturingDurationDays?.toString() || '120';
  map['ONSITE_DURATION_DAYS'] = projectData.onsiteDurationDays?.toString() || '90';
  
  // WARRANTY TERMS
  map['WARRANTY_FIT_FINISH_MONTHS'] = projectData.warrantyFitFinishMonths?.toString() || '24';
  map['WARRANTY_BUILDING_ENVELOPE_MONTHS'] = projectData.warrantyBuildingEnvelopeMonths?.toString() || '60';
  map['WARRANTY_STRUCTURAL_MONTHS'] = projectData.warrantyStructuralMonths?.toString() || '120';
  
  // LEGAL JURISDICTION
  map['PROJECT_STATE'] = projectData.siteState || '';
  map['PROJECT_COUNTY'] = projectData.projectCounty || projectData.siteCounty || '';
  map['PROJECT_FEDERAL_DISTRICT'] = projectData.projectFederalDistrict || '';
  map['ARBITRATION_PROVIDER'] = projectData.arbitrationProvider || 'JAMS';
  
  // SERVICE MODEL
  map['ON_SITE_SERVICES_SELECTION'] = projectData.serviceModel === 'CRC' 
    ? 'CLIENT-RETAINED CONTRACTOR' 
    : 'COMPANY-MANAGED ON-SITE SERVICES';
  
  // CRC-SPECIFIC
  if (projectData.serviceModel === 'CRC') {
    map['ONSITE_PROVIDER_NAME'] = projectData.contractorName || '';
    map['CONTRACTOR_LICENSE'] = projectData.contractorLicense || '';
    map['CONTRACTOR_NAME'] = projectData.contractorName || '';
  }
  
  // CMOS-SPECIFIC
  if (projectData.serviceModel === 'CMOS') {
    map['SITE_PREP_PRICE'] = formatCurrency(projectData.sitePrepPrice);
    map['UTILITIES_PRICE'] = formatCurrency(projectData.utilitiesPrice);
    map['COMPLETION_PRICE'] = formatCurrency(projectData.completionPrice);
  }
  
  return map;
}

// HELPER FUNCTIONS

function formatCurrency(value: string | number | undefined): string {
  if (value === undefined || value === null || value === '') return '$0';
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '$0';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(num);
}

function formatDate(dateString: string | undefined): string {
  if (!dateString) return '';
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return '';
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

function formatAddress(projectData: Record<string, any>): string {
  const parts = [
    projectData.siteAddress,
    projectData.siteCity,
    projectData.siteState,
    projectData.siteZip
  ].filter(Boolean);
  return parts.join(', ');
}

function getEntityTypeText(entityType: string | undefined): string {
  const types: Record<string, string> = {
    'Individual': 'individual',
    'LLC': 'limited liability company',
    'Corporation': 'corporation',
    'Partnership': 'partnership',
    'Trust': 'trust'
  };
  return types[entityType || 'Individual'] || 'individual';
}

function calculateEstimatedCompletion(projectData: Record<string, any>): string {
  if (!projectData.effectiveDate) return '';
  
  const startDate = new Date(projectData.effectiveDate);
  const totalDays = (parseInt(projectData.designPhaseDays) || 0) +
                   (parseInt(projectData.manufacturingDurationDays) || 0) +
                   (parseInt(projectData.onsiteDurationDays) || 0);
  
  const completionDate = new Date(startDate);
  completionDate.setDate(completionDate.getDate() + totalDays);
  
  return formatDate(completionDate.toISOString());
}
```

STEP 3: UPDATE API ENDPOINT

In server/routes.ts, update the contract generation endpoint to use the new generator:
```typescript
import { generateContract } from './lib/contractGenerator';
import fs from 'fs';
import path from 'path';

// Find and update the existing /api/contracts/generate-package endpoint
app.post('/api/contracts/generate-package', async (req, res) => {
  try {
    const { wizardData } = req.body;
    
    if (!wizardData) {
      return res.status(400).json({ error: 'Missing wizard data' });
    }
    
    console.log('\n========================================');
    console.log('CONTRACT GENERATION REQUEST');
    console.log('========================================');
    console.log('Project:', wizardData.projectNumber, '-', wizardData.projectName);
    console.log('Service Model:', wizardData.serviceModel);
    console.log('========================================\n');
    
    const contracts = [];
    const projectId = `proj_${Date.now()}`;
    
    // Ensure output directory exists
    const outputDir = path.join(__dirname, '../generated_contracts');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Generate each contract type
    const contractTypes: Array<'ONE' | 'MANUFACTURING' | 'ONSITE'> = ['ONE', 'MANUFACTURING', 'ONSITE'];
    
    for (const contractType of contractTypes) {
      try {
        const buffer = await generateContract({
          contractType,
          projectData: wizardData
        });
        
        // Create filename
        const filename = `${contractType}_Agreement_${wizardData.projectNumber || 'DRAFT'}.docx`;
        const filepath = path.join(outputDir, filename);
        
        // Save to disk
        fs.writeFileSync(filepath, buffer);
        console.log(`✓ Saved: ${filename} (${buffer.length} bytes)`);
        
        contracts.push({
          id: `contract_${Date.now()}_${contractType}`,
          type: contractType,
          filename,
          downloadUrl: `/api/contracts/download/${encodeURIComponent(filename)}`,
          size: buffer.length,
          generatedAt: new Date().toISOString()
        });
        
      } catch (error: any) {
        console.error(`✗ Failed to generate ${contractType}:`, error.message);
        throw error;
      }
    }
    
    console.log('\n========================================');
    console.log('✓ ALL CONTRACTS GENERATED SUCCESSFULLY');
    console.log('========================================\n');
    
    res.json({
      success: true,
      projectId,
      contracts,
      zipUrl: `/api/contracts/download-zip/${projectId}`
    });
    
  } catch (error: any) {
    console.error('\n========================================');
    console.error('✗ CONTRACT GENERATION FAILED');
    console.error('========================================');
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);
    console.error('========================================\n');
    
    res.status(500).json({ 
      error: 'Failed to generate contracts',
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Keep the existing download endpoint (should already exist)
// If it doesn't exist, add this:
app.get('/api/contracts/download/:filename', (req, res) => {
  try {
    const filename = decodeURIComponent(req.params.filename);
    const filepath = path.join(__dirname, '../generated_contracts', filename);
    
    if (!fs.existsSync(filepath)) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
        res.status(500).json({ error: 'Download failed' });
      }
    });
  } catch (error) {
    console.error('Download error:', error);
    res.status(500).json({ error: 'Download failed' });
  }
});
```

STEP 4: TEST THE IMPLEMENTATION

1. Start the development server
2. Load the test project (2025-TEST-001)
3. Navigate to Step 9 (Review & Generate)
4. Check the confirmation box
5. Click "Generate Contract Package"
6. Watch the server console logs for:
   - Clause fetching messages
   - Variable replacement logs
   - File generation success
7. Download the three generated DOCX files
8. Open each file in Microsoft Word or Google Docs
9. Verify:
   - Document structure looks professional
   - All sections/clauses are present
   - CRC-specific clauses included (since test project is CRC)
   - No {{VARIABLE_NAME}} placeholders remain
   - All variables replaced with actual values
   - Formatting is clean and readable

EXPECTED RESULTS:

Console should show something like:
========================================
CONTRACT GENERATION REQUEST
Project: 2025-TEST-001 - TEST PROJECT - Smith Residence
Service Model: CRC
=== Generating ONE Contract ===
Fetching clauses from: http://localhost:5000/api/clauses?contractType=ONE
Received 150 total clauses from API
Filtering clauses for service model: CRC
Excluding clause XXX (requires CMOS, have CRC)
After filtering: 142 clauses will be included
✓ Fetched 142 clauses
✓ Built variable map with 75 variables
✓ Processed 142 clauses with variable replacement
✓ Generated DOCX: 245678 bytes
✓ Saved: ONE_Agreement_2025-TEST-001.docx (245678 bytes)
[Similar for MANUFACTURING and ONSITE]
========================================
✓ ALL CONTRACTS GENERATED SUCCESSFULLY

TROUBLESHOOTING:

If "Failed to fetch clauses":
- Ensure PostgreSQL clause library is running
- Verify API endpoint /api/clauses is accessible
- Check that clauses exist in database

If variables aren't replaced:
- Check server logs to see variable map
- Open generated DOCX and search for {{
- Verify variable names match between clauses and map

If formatting looks wrong:
- The docx library creates basic formatting
- This is a starting point that can be enhanced
- Professional formatting can be added incrementally

This implementation dynamically assembles contracts from your clause library!